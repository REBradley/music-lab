import Euterpea
import Interlude

{--
offset     :: Dur -> Music a -> Music a
offset d m = rest d :+: m

times    :: Int -> Music a -> Music a
times 0 m = rest 0
times n m = m :+: times (n - 1) m

forever   :: Music a -> Music a
forever m = m :+: forever m

lineToList                 :: Music a -> [Music a]
lineToList (Prim (Rest 0)) = []
lineToList (n :+: ns)      = n : lineToList ns
lineToList _               =
    error "lineToList: argument not created by function line"


invert :: Music Pitch -> Music Pitch
invert = 
    let l@(Prim(Note _ r) : _) = lineToList m
        inv (Prim(Note d p)) = 
                 note d (pitch (2*absPitch r - absPitch p))
        inv (Prim (Rest d))  = rest d
    in line $ map inv
--}

{--EXERCISE 6.1: Show that retro . retro, invert . invert, and
 - retroInvert . invertRetro are the identities on values created by line. (You
 - may use the lemma that reverse (reverse l) = l).
 -
retro . retro $ l  = line . reverse . lineToList . line . reverse . lineToList $ l
                   = line . reverse . (lineToList . line) . reverse . lineToList $ l
                   = line . reverse . reverse . lineToList $ l
                   = line . lineToList $ l
                   = l

invert . invert $ mel = (line $ map inv $ lineToList) . (line $ map inv $ lineToList) $ mel
                      = (line $ map inv) . (lineToList . line) . (map inv $ lineToList) $ mel
                      = (line $ map inv) . (map inv $ lineToList) $ mel
                      = line $ (map inv) . (map inv) $ lineToList $ mel
                      = line $ map (inv . inv) $ lineToList $ mel
                      = line $ map id $ lineToList $ mel
                      = mel


retroInvert . invertRetro $ l = (retro . invert) . (invert . retro) $ mel
                              = retro . (invert . invert) . retro $ mel
                              = retro . retro $ mel
                              = mel

 -
 - --}

{--
 - EXERCISE 6.2: Define a function properRow :: Music Pitch -> Bool that
 - determines whether or not its argument is a "proper" 12-tone row, meaning
 - that: (a) it must have exactly 12 notes, and (b) each unique pitch class is
 - used exactly once (regardless of the octave). Enharmonically equivalent pitch
 - classes are not considered unique. You may assume that the Music Pitch value
 - is generated by the function line, but note that rests are allowed.
--}
            
excludeRests :: [Music a] -> [Music a]
excludeRests ns = filter ifRest ns
                  where ifRest n = case n of 
                                  (Prim(Note d p)) -> True; (Prim(Rest d)) -> False

properRow :: Music Pitch -> Bool
properRow row = let l = excludeRests $ lineToList row
                    makeEnharmonicEqPC (Prim(Note d p)) = note d (pitch(absPitch p))
                    getPC (Prim(Note d (pc,o))) =  pc
                    isUnique (p:ps) = (not $ elem p ps) : isUnique ps
                    isUnique [] = []
                    is12Notes = (== 12) . length
                in (is12Notes l) && (and $ isUnique $ map (getPC . makeEnharmonicEqPC) l)

palin :: Music Pitch -> Bool
palin row = let l = excludeRests $ lineToList row
                rl = reverse l
            in l == rl

{--EXERCISE 6.4: Define a funtion retroPitches :: Music Pitch -> Music Pitch
 - that reverses the pitches in a line but maintains the durations in the same
 - order from beginning to end. For example:
 -
 - retroPitches (line [c 4 en, d 4 qn]) -> (line [d 4 en,c 4 qn])
--}



retroPitches :: Music Pitch -> Music Pitch
retroPitches row = let l = lineToList row
                       pitchToNote (Prim (Note d _)) = note d
                       getPitch (Prim (Note _ p)) = p
                       fuse (f:fs) (p:ps) = f p : fuse fs ps
                       fuse [] [] = []
                    in line . fuse (map pitchToNote l) $ (map getPitch $ reverse l)



{--

dur                      :: Music a -> Dur
dur (Prim (Note d _))    = d
dur (Prim (Rest d))      = d
dur (m1 :+: m2)          = dur m1 + dur m2
dur (m1 :=: m2)          = dur m1 `max` dur m2
dur (Modify (Tempo r) m) = dur m/r
dur (Modify _ m)         = dur m


retro                   :: Music a -> Music a
retro n@(Prim _)   = n
retro (Modify c m) = Modify c (retro m)
retro (m1 :+: m2)  = retro m2 :+: retro m1
retro (m1 :=: m2)  = 
    let d1 = dur m1
        d2 = dur m2
    in if d1 > d2 then retro m1 :=: (rest (d1-d2) :+: retro m2)
                  else (rest (d2 - d1) :+: retro m1) :=: retro m2

--}

infMusic = forever $ c 4 qn

infMusic2 = forever $ chord [c 3 hn, e 3 hn, g 3 hn]

infMusic3 = forever $ line [c 4 en, e 4 qn, g 4 sn, c 5 sn]

infMusic4 = forever $ line [c 7 wn, g 7 wn]


{--

cut :: Dur -> Music a -> Music a
cut d m | d <= 0         = rest 0
cut d (Prim(Note oldD p) = note (min oldD d) p
cut d (Prim(Rest oldD))  = rest (min oldD d)
cut d (m1 :=: m2)        = cut d m1 :=: cut d m2
cut d (m1 :+: m2)        = let m'1 = cut d m1
                                 m'2 = cut (d - dur m'1) m2
                              in m'1 :+: m'2
cut (Modify (Tempo r) m) = tempo r (cut(d * r) m)
cut d (Modify c m)       = Modify c (cut d m)


remove :: Dur -> Music a -> Music a
remove d m | d <= 0           = m
remove d (Prim (Note oldD p)) = note (max (oldD - d) 0) p
remove d (Prim (Rest oldD))   = rest (max (oldD - d) 0)
remove d (m1 :=: m2)          = remove d m1 :=: remove d m2
remove d (m1 :+: m2)          = remove d m1 :+: remove (d - dur m1) m2
remove d (Modify (Tempo r) m) = tempo r (remove (d * r) m)
remove d (Modify c m)         = Modify c (remove d m)



removeZeros :: Music a -> Music a
removeZeros (Prim p)    = Prim p
removeZeros (m1 :+: m2) =
    let m'1 = removeZeros m1
        m'2 = removeZeros m2
    in case (m'1, m'2) of
        (Prim (Note 0 p),m) -> m
        (Prim (Rest 0),m)   -> m
        (m,Prim (Note 0 p)) -> m
        (m,Prim (Rest 0))   -> m
        (m1,m2)             -> m1 :+: m2
removeZeros (m1 :=: m2) = 
    let m'1 = removeZeros m1
        m'2 = removeZeros m2
    in case (m'1,m'2) of 
        (Prim (Note 0 p),m) -> m
        (Prim (Rest 0),m)   -> m
        (m,Prim (Note 0 p)) -> m
        (m,Prim (Rest 0))   -> m
        (m1,m2)             -> m1 :=: m2
removeZeros (Modify c m)    = Modify c (removeZeros m)

type LazyDur = [Dur]
durL :: Music a -> LazyDur
durL m@(Prim _)           = [dur m]
durL (m1 :+: m2)          = let d1 = durL m1
                            in d1 ++ map (+(last d1)) (durL m2)
durL (m1 :=: m2)          = mergeLD (durL m1) (durL m2)
durL (Modify (Tempo r) m) = map (/r) (durL m)
dur: (Modify _ m)         = durL m

mergeLD :: LazyDur -> LazyDur -> LazyDur 
mergeLD [] ld = ld
mergeLD ld [] = ld
mergeLD ld1@(d1:ds1) ld2@(d2:ds2) = 
    if d1 < d2 then d1 : mergeLD ds1 ld2
               else d2 : mergeLD ld1 ds2

minL :: LazyDur -> Dur -> Dur
minL []    d' = 0
minL [d]   d' = min d d'
min (d:ds) d' = if d < d' then minL ds d'

cutL :: LazyDur -> Music a -> Music a
cutL [] m                   = rest 0
cutL (d:ds) m | d<=0        = cutL ds m
cutL ld (Prim(Note oldD p)) = note (minL ld oldD) p
cutL ld (Prim(Rest oldD))   = rest (minL ld oldD)
cutL ld (m1 :=: m2)         = cutL ld m1 :=: cutL ld m2
cutL ld (m1 :+: m2)         = 
    let m'1 = cutL ld m1
        m'2 = cutL (map(\d -> d - dur m'1) ld) m2
    in m'1 :+: m'2
cutL ld (Modify (Tempo r) m) = tempo r ( cutL (map (*r) ld) m)
cutL ld (Modify c m)         = Modify c (cutL ld m)


(/=:)       :: Music a -> Music a -> Music a
m1 /=: m2 = cutL (durL m2) m1 :=: cutL (durL m1) m2

--}
trill :: Int -> Dur -> Music Pitch -> Music Pitch
trill i sDur (Prim(Note tDur p)) = 
    if sDur >= tDur then note tDur p
                    else note sDur p :+: 
                         trill (negate i) sDur
                               (note (tDur - sDur) (trans i p))
trill i d (Modify (Tempo r) m) = tempo r (trill i (d*r) m)
trill i d (Modify c m) = Modify c (trill i d m)
trill _ _ _            = 
    error "trill: input must be a single note."


trill' :: Int -> Dur -> Music Pitch -> Music Pitch
trill' i sDur m = trill (negate i) sDur (transpose i m)

trilln :: Int -> Int -> Music Pitch -> Music Pitch
trilln i nTimes m = trill i (dur m/fromIntegral nTimes) m

trilln' :: Int -> Int -> Music Pitch -> Music Pitch
trilln' i nTimes m = trilln (negate i) nTimes (transpose i m)

roll  :: Dur -> Music Pitch -> Music Pitch
rolln :: Int -> Music Pitch -> Music Pitch

roll dur m = trill 0 dur m
rolln nTimes m = trilln 0 nTimes m

ssfMel :: Music Pitch
ssfMel = line (l1 ++ l2 ++ l3 ++ l4)
    where l1 = [ trilln 2 5 (bf 6 en), ef 7 en,ef 6 en, ef 7 en ]
          l2 = [ bf 6 sn, c 7 sn, bf 6 sn, g 6 sn, ef 6 en, bf 5 en ]
          l3 = [ ef 6 sn, f 6 sn, g 6 sn, af 6 sn, bf 6 en, ef 7 en ]
          l4 = [ trill 2 tn (bf 6 qn), bf 6 sn, denr ]

starsAndStripes :: Music Pitch
starsAndStripes = instrument Flute ssfMel

grace :: Int -> Rational -> Music Pitch -> Music Pitch
grace n r (Prim (Note d p)) = 
    note (r * d) (trans n p) :+: note ((1 - r) * d) p
grace n r _                 =
    error "grace: can only add a grace note to a note"

grace2 :: Int -> Rational ->
          Music Pitch -> Music Pitch -> Music Pitch
grace2 n r (Prim(Note d1 p1)) (Prim(Note d2 p2)) = 
    note (d1 - r * d2) p1 :+: note (r * d2) (trans n p2) :+: note d2 p2
grace2 _ _ _ _ = 
    error "grace2 : can only add a grace note to a note"

{--
-- note (d/3) :+: trans 1 note :+: dotted note (d/3)
-- mordent c 4 qn = c 4 tn :+: d 4 tn :+: c 4 den
--       8/32     =   1/32  +    1/32  +    6/32
--}
mordent :: Music Pitch -> Music Pitch
mordent n@(Prim(Note d p)) = trilln 1 2 (note (d/4) p) :+: note (3*d/4) p





turn :: Music Pitch -> Music Pitch
turn (Prim(Note d p)) = line $ map (\i -> note (d/4) (trans i p)) [1,0,-1,0]

turn' :: Music Pitch -> Music Pitch
turn' (Prim(Note d p)) = let halfDur = note (d/2) p
                         in trilln' 1 2 halfDur :+: trilln' (-1) 2 halfDur

turn'' :: Music Pitch -> Music Pitch
turn'' (Prim(Note d p)) = let halfDur = note (d/2) p
                         in grace 1 (1/2) halfDur :+: grace (-1) (1/2) halfDur

appoggiatura :: Music Pitch -> Music Pitch
appoggiatura n = grace 1 (1/2) n



funkGroove :: Music Pitch
funkGroove
    = let p1 = perc LowTom        qn
          p2 = perc AcousticSnare en
      in tempo 3 $ cut 8 $ forever
          ((p1 :+: qnr :+: p2 :+: qnr :+: p2 :+:
            p1 :+: p1 :+: qnr :+: p2 :+: enr)
            :=: roll en (perc ClosedHiHat 2))

allDrumBeats :: Music Pitch
allDrumBeats = line $ map (\x -> offset qn $ perc (toEnum x) en) [3..5]


impeachPresidentTrump :: Music Pitch
impeachPresidentTrump = 
    let pk = perc BassDrum1 qn
        ps = perc ElectricSnare qn
        po = perc OpenHiHat qn
        pc = perc ClosedHiHat qn
        pke = perc BassDrum1 en
        pce = perc ClosedHiHat en
        
    in tempo (180/120) $ cut 8 $ forever
         ((pk :=: pc) :+: pc :+: (ps :=: pc) :+: pce :+: (pke :=: pce) :+:
         (pk :=: pc) :+: po :+: (ps :=: pc) :+: (pk :=: pc))
--         :=: (times 2 (c 5 hn :+: (grace2 1 (1/4) (g 5 hn) (e 5 hn)) :+: trill 1 en (c 5 hn)
--         :+: c 5 hn :+: e 5 hn :+: g 5 hn :+: trill (1) en (c 5 hn)))


{--
 -
 -
 -
 -
 -
 -
 -
 -
 -

pMap ::         (a -> b) -> Primitive a -> Primitive b
pMap f (Note d x) = Note d (f x)
pMap f (Rest d)   = Rest d


mMap              :: (a -> b) -> Music a -> Music b
mMap f (Prim p) = Prim (pMap f p)
mMap f (m1 :+: m2) = mMap f m1 :+: mMap f m2
mMap f (m1 :=: m2) = mMap f m1 :=: mMap f m2
mMap f (Modify c m) = Modify c (mMap f m)



type Volume = Int


addVolume       :: Volume -> Music Pitch -> Music (Pitch, Volume)
addVolume v = mMap (\p -> (p,v))

--}

m1, m2 :: Music (Pitch, Volume)
m1 = addVolume 100 (c 4 qn :+: d 4 qn :+: e 4 qn :+: c 4 qn)
m2 = addVolume 30 (c 4 qn :+: d 4 qn :+: e 4 qn :+: c 4 qn)



--EXERCISE 6.9

scaleVolume :: Rational -> Music (Pitch, Volume) 
                        -> Music (Pitch, Volume)
scaleVolume s m = mMap (\(p,v) -> (p, round(s*fromIntegral v)) ) m


{--
mFold :: (Primitive a -> b) -> (b -> b -> b) -> (b -> b -> b) ->
         (Control -> b -> b) -> Music a -> b
mFold f (+:) (=:) g m = 
    let rec = mFold f (+:) (=:) g
    in case m of 
        Prim p -> f p
        m1 :+: m2 -> rec m1 +: rec m2
        m1 :=: m2 -> rec m1 =: rec m2
        Modify c m -> g c (rec m)

mMap :: (a -> b) -> Music a -> Music b
mMap f = mFold g (:+:) (:=:) Modify where 
    g (Note d x) = note d (f x)
    g (Rest d)   = rest d

dur :: Music a -> Dur
dur = mFold getDur (+) max modDur where 
    getDur (Note d _)  = d
    getDur (Rest d)    = d
    modDur (Tempo r) d = d/r
    modDur _ d         = d
--}

mRetro :: Music Pitch -> Music Pitch
mRetro = mFold Prim (revOp) (:=:) Modify where
    m1 `revOp` m2 = m2 :+: m1

{--
 -
 - EXERCISE 6.11: Define a function insideOut that inverts the role of serial
 - and parallel composition in a Music value. Using insideOut, see if you can (a)
 - find a non-trivial value m :: Music Pitch such that m is "musically
 - equivalent" to (i.e. sounds the same as) insideOut m and (b) find a value m
 - :: Music Pitch such that    m :+: insideOut m :+: m      sounds interesting.
 -
 - find m = m1 :+: m2  -- dur remains the same
 -        = m1 :=: m2
 -         case (m1, m2) of 
 -            (Note, Note) -> ( Note d p, Volume 0 Note d p  )
 -            (Note, Rest) -> (Note d p, Rest 0)
 -            (Rest, Rest) -> ( Rest d, Rest d  )
 -
 - find m = m1 :+: m2 :=: m3  -- dur remains the same
 -        = m1 :=: m2 :+: m3
 -        
 - find m = m1 :+: m2 :=: m3  -- dur remains the same
 -        = m1 :=: m2 :+: m3
 -
 -        m1 = m3 = c 4 qn
 -        m2 = rest hn
 -
 -
 - --}

insideOut :: Music Pitch -> Music Pitch
insideOut = mFold Prim (:=:) (:+:) Modify

insOutComp :: Music Pitch -> Music Pitch
insOutComp m = m :+: insideOut m :+: m



--COMPLEX RHYTHMS
x1 = g 4 qn :=: (c 4  en :+: d 4 en :+: e 4 en)
x2 = g 4 qn :=: tempo (3/2) (c 4  en :+: d 4 en :+: e 4 en)



phaseIt factor m = m :=: tempo factor m
phase1 = phaseIt 1.5 (times 4 twinkle)
phase2 = phaseIt 1.1 (times 4 twinkle)
phase3 = phaseIt 1.01 (times 4 twinkle)


rep :: (Music a -> Music a) -> (Music a -> Music a) -> Int 
       -> Music a -> Music a
rep f g 0 m = rest 0
rep f g n m = m :=: g(rep f g (n-1) (f m))

run      = rep (transpose 5) (offset tn) 8 (c 4 tn)
cascade  = rep (transpose 4) (offset en) 8 run
cascades = rep id (offset sn) 2 cascade

final = cascades :+: retro cascades

run'      = rep (offset tn) (transpose 5) 8 (c 4 tn)
cascade'  = rep (offset en) (transpose 4) 8 run'
cascades' = rep (offset sn) id 2 cascade'

final'    = cascades' :+: retro cascades'




intervalList :: [Int] -> [Int]
intervalList [x]       = []
intervalList (x:y:xys) = (y-x) : intervalList (y:xys)

toIntervals :: [Int] -> [[Int]]
toIntervals [] = []
toIntervals l = l : toIntervals(intervalList l)

getHeads   :: [[Int]] -> [Int]
getHeads = map (\(x:_) -> x)

intervalClosure :: [Int] -> [Int]
intervalClosure = getHeads . toIntervals

intervalClosures :: [Int] -> [[Int]]
intervalClosures xs = intervalClosure xs : intervalClosures(intervalClosure xs)


intToRationalTrig :: (Real a) => (a -> a) -> Int -> Rational
intToRationalTrig f x = realToFrac $ f (fromIntegral x)

listToTrigBass :: (Real a) => (a -> a) -> [Int] -> [Music Pitch]
listToTrigBass f = 
    let toTrigBass f = \x -> perc BassDrum1 ((intToRationalTrig f x + 1)/4)
    in map $ toTrigBass f

listToTrigSnare :: (Real a) => (a -> a) -> [Int] -> [Music Pitch]
listToTrigSnare f = 
    let toTrigSnare f = \x -> perc ClosedHiHat ((intToRationalTrig f x + 1)/8)
    in map $ toTrigSnare f
    
trigChord :: [Int] -> Music Pitch
trigChord xs = 
    let sinBass = listToTrigBass sin
        cosSnare = listToTrigSnare cos
    in (line $ sinBass xs) :=: (line $ cosSnare xs)

{--EXERCISE 6.13: Write a Euterpea program that sounds like an infinitely
 - descending (in pitch) sequence of musical lines. Each descending line should
 - fade into the audible range as it begins its descent, and then fade out as
 - it descends further. So the beginning and end of each line will be difficult
 - to hear. And there will be many such lines, each starting at a different
 - time, some perhaps descending a little faster than others, or perhaps using
 - different instrument sounds, and so on. The effect will be that as you listen
 - to the music, everything will seem to be falling, falling, falling, with no
 - end, but no beginning either.
 -
 - Use higher-order functions, recursion, and whatever other abstraction
 - techniques you have learned to write an elegant solution to this problem. Try
 - to parameterize things in such a way that, for example, with a simple change,
 - you could generate an infinite ascention as well. The Volume constructor in
 - the NoteAttribute type, as used in the definition of addVol, should be used
 - to set the volumes. --}


increasingPitchRange, decreasingPitchRange :: [AbsPitch]
increasingPitchRange = [1..120]
decreasingPitchRange = reverse increasingPitchRange

volumeRange :: [Volume]
volumeRange = [0,2..120] ++ (reverse [0,2..116])

instruments :: [InstrumentName]
instruments = map toEnum [2..16]

createNote :: AbsPitch -> Volume -> Dur -> Music (Pitch,Volume)
createNote p v d = offset d $ note d (pitch p,v)

deltaLine :: [AbsPitch] -> [Volume] -> Dur -> [Music (Pitch,Volume)]
deltaLine (p:ps) (v:vs) d = createNote p v d : deltaLine ps vs d
deltaLine _ _ _ = []

descendingLines,ascendingLines :: Dur -> [[Music (Pitch,Volume)]]
descendingLines d = deltaLine decreasingPitchRange volumeRange d : descendingLines (d*0.98)
ascendingLines d = deltaLine increasingPitchRange volumeRange d : ascendingLines (d*0.98)

parallelOffsetLines :: [[Music (Pitch,Volume)]] -> [InstrumentName] -> Music (Pitch,Volume)
parallelOffsetLines _ [] = rest 0
parallelOffsetLines (ms:mss) (i:is) = instrument i $ line ms :=: parallelOffsetLines mss is


